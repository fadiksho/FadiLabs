@using System.Diagnostics
@code {
	[Inject] public IServiceExecutor<IUIBus> ServiceExecutor { get; set; } = default!;
	[Inject] public required CreatePostValidator CreatePostValidator { get; set; }
	[Inject] public required ISnackbar Snackbar { get; set; }
	[Inject] public required NavigationManager Navigation { get; set; }

	private Result<CreatePostResponse> createPostResult;

	private Result<PagedList<TagResponse>> tagsResponse;
	private List<TagResponse> selectedTags = [];
	private string? filterSearchTagInput;

	private MudAutocomplete<string> mudAutocomplete = default!;
	private MudForm form = default!;

	private CreatePost createPostRequest = new();

	private async Task<IEnumerable<string>> SearchTags(string value, CancellationToken token)
	{
		IEnumerable<string> filterTags = [];

		if (ServiceExecutor.IsRequestLoading(nameof(GetTags)))
			return filterTags;

		if (!tagsResponse.IsDefined || tagsResponse.IsFailed)
			tagsResponse = await ServiceExecutor.ExecuteAsync(nameof(GetTags), x => x.Send(new GetTags()));

		if (tagsResponse.IsSuccess)
		{
			// filter tags to exclude those already present (case-insensitive)
			filterTags = tagsResponse.Entity.Items
				.Where(tag => !selectedTags
					.Any(existingTag => existingTag.Name.Equals(tag.Name, StringComparison.CurrentCultureIgnoreCase)))
					.Select(x => x.Name);

			// further filter to include only those whose Name contains the filtered string (case-insensitive)
			if (!string.IsNullOrEmpty(value))
				filterTags = filterTags.Where(tag => tag.Contains(value, StringComparison.InvariantCultureIgnoreCase));
		}

		return filterTags;
	}
	

	private async Task HandleTagKeyDownHandler(KeyboardEventArgs args)
	{
		if (args.Key == "Enter" && !string.IsNullOrEmpty(filterSearchTagInput) && tagsResponse.IsSuccess)
		{
			var selectedTag = tagsResponse.Entity.Items
			.FirstOrDefault(x => x.Name.Equals(filterSearchTagInput, StringComparison.InvariantCultureIgnoreCase));

			if (selectedTag == null)
			{
				selectedTag = new TagResponse { Name = filterSearchTagInput };
			}

			var tagAlreadySelected = selectedTags.Any(x => x.Name.Equals(selectedTag.Name, StringComparison.InvariantCultureIgnoreCase));
			if (!tagAlreadySelected)
				selectedTags.Add(selectedTag);

			await mudAutocomplete.ClearAsync();
		}
	}

	private void RemoveTag(TagResponse tag)
	{
		selectedTags.Remove(tag);
	}

	private async Task Submit()
	{
		await form.Validate();

		if (form.IsValid)
		{
			createPostRequest.Tags = selectedTags;
			createPostResult = await ServiceExecutor
				.ExecuteAsync(nameof(CreatePost), x => x.Send(createPostRequest));

			if (createPostResult.IsSuccess)
			{
				selectedTags.Clear();
				createPostRequest.ResetToDefault();

				Snackbar.Add(createPostResult.Entity.Title, Severity.Normal, config =>
				{
					config.Action = "Edit";
					config.ActionColor = Color.Primary;
					config.Onclick = snackbar =>
					{
						Navigation.NavigateTo($"/blog/edit/{createPostResult.Entity.PostId}");
						return Task.CompletedTask;
					};
				});
			}
		}
	}
}

<Shared.Components.Components.Shared.RenderingContextMessage />
<MudPaper Class="pa-4">
	<MudForm Model="@createPostRequest" @ref="@form" Validation="@(CreatePostValidator.ValidateValue)" ValidationDelay="0">
		<MudStack>
			<MudTextField @bind-Value="createPostRequest.Title"
										For="@(() => createPostRequest.Title)"
										Immediate="true"
										Label="Title" />

			<MudTextField @bind-Value="createPostRequest.Description"
										For="@(() => createPostRequest.Description)"
										Lines="5"
										Immediate="true"
										Label="Description" />

			<MudAutocomplete T="string"
											 Label="Tags"
											 @ref="mudAutocomplete"
											 @bind-Value="filterSearchTagInput"
											 Immediate="true"
											 CoerceValue="true"
											 CoerceText="false"
											 ResetValueOnEmptyText="false"
											 OnKeyDown="HandleTagKeyDownHandler"
											 SearchFunc="@SearchTags"
											 TextUpdateSuppression="false"
											 Clearable="true"
											 OnClearButtonClick="@(async () => await mudAutocomplete.ClearAsync())"
											 ShowProgressIndicator="true"
											 ProgressIndicatorColor="Color.Primary">
			</MudAutocomplete>
			<MudStack Row="true" Spacing="1" Wrap="Wrap.Wrap">
				@foreach (var selectedTag in selectedTags)
				{
					<MudChip T="string" Color="(Guid.Empty == selectedTag.TagId ? Color.Success : Color.Default)"
									 OnClose="() => RemoveTag(selectedTag)">@selectedTag.Name</MudChip>
				}
			</MudStack>
			<MudButton Variant="Variant.Filled" Color="Color.Primary" Class="ml-auto" OnClick="@(async () => await Submit())">Save</MudButton>
		</MudStack>
	</MudForm>
</MudPaper>
